# Quest05

## Topics
* Separation of Concerns

> https://kaki104.tistory.com/725
> 
> ### Separation of Concerns (SoC, 관심사의 분리)
>
> 관심사의 분리는 소프트웨어 개발에서 가장 기본적인 원칙 중 하나이며, SOLID 원칙 5개 중 2개(단일 책임 및 인터페이스 분리)가 이 개념에서 직접 파생될 정도로 매우 중요하다.
> 
> 원칙은 프로그램을 하나의 단일 블록으로 작성하지 말고 작은 조각으로 나누어 각각 간단한 개별 작업을 완료할 수 있도록 만드는 것이다.
> 
> ### SoC for programing functions
> 
> 가장 낮은 레벨(실제 프로그래밍 코드)에서 SoC 는 긴 복잡한 함수를 쓰지 않는 것이다. 함수의 크기가 커지는 것은 함수가 너무 많은 작업을 처리한다는 것이고, 이는 함수를 분리해야 한다는 신호이다.
> 
> ### SoC for modules
> 
> 조금 더 높으 수준에서 SoC 는 각각 논리적 상관관계가 분명한 단일 작업 세트를 만들고, 모듈하에서 함수를 그룹화하는 것이다.
> 
> 함수에 대해 수행하는 것과 동일하게, 덜 밀접한 기능들을 분리하고 동일한 고유 목적을 제공하는 기능을 그룹화한다.
> 
> ### Cohesion and Coupling
> 
> SoC 의 적용은 결합의 감소와 응집력의 증가라는 두가지 과정을 포함한다.
> 
> 응집력은 역할 유사성을 의미하고, 커플링은 시스템의 나머지 부분에 대한 부품의 의존도를 말한다.
> 
> 개발을 진행할 때, Loose Coupling(느슨한 커플링)과 High Cohesion(높은 응집력)을 목표로 해야 한다.
> 
> ### Benefit of Loose Coupling and High Cohesion
> 
> **명료한 코드**: 메소드의 범위가 논리적으로 지정되고, API 가 간결하고 명확하며, 각 모듈이 이러한 메소드와 API 를 가진다면 프로그램에서 어떤 일이 일어나는지 이해하기 쉽다.
> 
> **코드 재사용성 향상(DRY 원리)**: 코드를 재사용하는 것의 주된 이점은 유지관리 비용의 절감이다. 기능을 확장하거나 버그를 수정할 때 한 곳을 수정하는 것이 훨신 간편하다.
> 
> **테스트 기능성**: 적절한 범위의 기능을 가진 독립 모듈을 테스트하는 것이 훨씬 간편하다. 모듈의 작동을 확인하기 위해 전체 환경을 파악하지 않고, 모듈의 동작만을 확인하면 된다.
> 
> **프로젝트 개발 및 유지보수 성능**: 새로운 기능이든 기존 기능이든 모듈 격리는 프로그램의 변경사항으로 영향 받을 수 있는 영역을 지정하는데 도움이 되어 개발 속도가 빨라진다.
>
> **동시 개발 용이**: 여러 개발자가 동시에 개발할 때 서로 간섭하지 않도록 하기 위해 어떤 모듈을 진행할지 합의하면 된다. 모듈의 API 업데이트를 통해 다른 개발자에게 명시적으로 변경 사항을 알릴 수 있고, 이를 통해 병렬 개발도 단독 작업과 유사하게 생산성이 효율적으로 될 수 있다.

* 객체지향의 설계 원칙
  * SOLID 원칙

> 문법 공부를 끝낸 수준에서 프로그램을 만들다보면 쉽게 스파게티 코드가 된다. 이는 프로그래밍이 아닌 코딩을 하기 쉽기 때문이다.
> 
> ### SOLID 원칙
> 
> **S**: Single Responsibility Principle (단일 책임 원칙)
> **O**: Open-Closed Principle (개방 폐쇄 원칙)
> **L**: Liskov Subsitution Principle (리스코프 치환 원칙)
> **I**: Interface Segregation Principle (인터페이스 분리 원칙)
> **D**: Dependency Inversion Principle (의존성 역전 원칙)
>
> ### Single Responsibility
> 
> 단일 책임 원칙이란 간단히 말하면 클래스가 단일 책임을 맡는다는 의미이다.
> 
> 만약 하나의 클래스에 모든 동작을 집어넣다보면 시스템은 점차 비대해지고, 한 부분이 고장났을 때 전체가 동작하지 않게 된다. 하나의 클래스 안에서 메서드끼리 거미줄처럼 연결되어 있다면 더욱 그렇다.
> 
> 깔끔한 설계를 위해서는 어떠한 경우에도 클래스는 단일 책임을 져야 한다. 하지만 막상 객체 설계를 시작하면 클래스의 책임 범위를 어떻게 두어야 하는지 고민되는 경우가 많다. 보통 이런 경우에는 메서드의 '실패상황'을 가정해보면 클래스의 책임 범위를 비교적 쉽게 파악할 수 있다. 기능이 실패했을 때 특정 프로퍼티의 값에 영향이 미친다면 해당 클래스가 바로 책임자일 가능성이 높다.
> 
> ### Open-Closed Principle
> 
> 개방-폐쇄 원칙은 구체적으로는 '확장은 개방, 수정은 폐쇄' 원칙이다. 이는 '아웃소싱' 개념과 비슷한 점이 있다.
> 
> 힐튼 호텔과 에어비엔비를 보면, 둘 모두 숙박업에 속하지만, 에어비엔비는 개인 소유의 주거 공간을 아웃소싱하지만 힐튼 호텔은 토지를 확보하고, 관광 및 숙박시설 허가를 받아 숙박시설을 건립한다. 여기에서 에어비엔비는 확장에 개방적이며, 수정에 폐쇄적인(에어비엔비가 호스트의 집을 수정할 수 없다) 모습을 보여주며, 이는 사업의 효율성을 보았을 때 높은 성장 속도를 보여주게 된다.
> 
> 에어비엔비는 호스트 클래스를 받기만 할 뿐 자신이 무언가 기능을 구사하지 않는다. 이러한 클래스를 '추상클래스'라고 한다.
> 
> ### Liskov Subsitution Principle
> 
> 리스코프 치환의 원칙을 검색해보면 다음과 같은 설명이 나온다.
> 
> > 치환형은 객체 지향 프로그램의 원칙이다. 컴퓨터 프로그램에서 자료형 (a) 가 자료형 (A) 의 하위형이라면 필요한 프로그램의 속성의 변경 없이 자료형 (A) 의 객체를 자료형 (a) 의 객체로 교체할 수 있어야 한다는 원칙이다.
> 
> 객체지향 프로그래밍에서 리스코프 치환의 원칙을 사용해야하는 이유는 '복제'와 관련이 깊다.
> 
> 객체지향에서 '복제'를 간단하게 사용하는 방법은 '상속' 이다. 자바스크립트에서 상속은 extends 라는 키워드를 사용하면 된다. 그리고 `super()` 라는 메서드를 통해 상위 클래스의 특징과 기능을 그대로 복제할 수 있다.
> 
> 예를 들면 사각형이라는 클래스가 있고 정사각형이라는 클래스가 있을 때, 정사각형이라는 클래스는 사각형이라는 부모 클래스를 상속하되, 정사각형만의 특징인 변의 길이가 같다는 사실만 새롭게 지정해주면 된다.
> 
> ### Interface Segregation Principle
> 
> 인터페이스 분리 원칙을 검색해보면 다음과 같은 설명이 나온다.
> 
> > 인터페이스 분리 원칙은 클리아언트가 자신이 이용하지 않는 메서드에 의존하지 않아야 한다는 원칙이다. 인터페이스 분리 원칙은 큰 덩어리의 인터페이스들을 구체적이고 작은 단위들로 분리시킴으로 써 클라이언트들이 꼭 필요한 메서드들만 이용할 수 있게 한다.
> 
> 인터페이스는 서로 간섭을 일으키지 않아야 하고, 내부 동작과 직접적으로 연결되어서도 안 된다. 이 부분은 객체지향 설계의 유연성에 있어 중요하다.
> 
> 예를 들어 Machine 이라는 클래스에 print, fax, scan 메서드가 들어가 있다고 할 때, 그 중 print 기능만 이용하는 저가형 프린터를 만들기 위해 Machine 클래스를 상속한다면, 필요 없는 fax 와 scan 메서드를 같이 가져올 뿐더러 이 기능들을 실행하면 아무런 동작이 일어나지 않으므로, 동작이 일어나지 않는다는 예외 표시 처리 또한 해주어야 한다. 이러한 경우를 막기 위해 print, fax, scan 은 각각 다른 클래스로 분리(인터페이스 분리) 해주어야 한다.
> 
> 인터페이스가 모두 분리되었을 때, 두가지 이상의 기능을 동시에 상속하고 싶다면 aggregation 방식을 이용하여 한번에 상속할 수 있다. aggregation 함수는 클래스를 받아 배열로 만들어 모아주는 역할을 한다.
>
> ### Dependency Inversion Principle
> 
> 의존성 역전은 말 그대로 의존성이 역전이 되면 안된다는 의미인데, 의존하는 객체가 직접적으로 중앙 시스템에 요구사항을 요청할 경우 시스템 전체가 무너질 수 있다.
>
> 의존하는 객체(인터페이스)는 중앙 시스템에 직접적으로 접근해서는 안되며, 대리인을 통해 의사를 전달만 할 수 있다.

* Local Storage

> ### Window.localStorage
> 
> localStorage 읽기 전용 속성을 사용하면 Document 의 Storage 객체에 접근할 수 있고, 여기에 저장된 데이터는 브라우저 세션 간에 공유된다. localStorage 의 데이터는 만료되지 않는다는 점에서 페이지 세션이 끝날 때 사라지는 sessionStorage 와 차이점을 갖는다.
> 
> 키와 값은 항상 각 문자에 2바이트를 할당하는 UTF-16 DOMString 형태로 저장된다.

## Checklist
* 관심사의 분리 원칙이란 무엇인가요? 웹에서는 이러한 원칙이 어떻게 적용되나요?
* 객체지향의 SOLID 원칙이란 무엇인가요? 이 원칙을 구체적인 예를 들어 설명할 수 있나요?
* 로컬 스토리지란 무엇인가요? 로컬 스토리지의 내용을 개발자 도구를 이용해 확인하려면 어떻게 해야 할까요?