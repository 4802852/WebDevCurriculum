# Quest 11. RDB의 기초와 ORM

## Introduction
* 이번 퀘스트에서는 데이터베이스를 다루는 방법에 대해 알아보겠습니다.

## Topics
* RDBMS

> ### RDBMS: 관계형 데이터베이스
>
> 데이터가 하나 이상의 열과 행의 테이블에 저장되어 서로 다른 데이터 구조가 어떻게 관련되어 있는지 쉽게 파악하고 이해할 수 있도록 사전에 정의된 관계로 데이터를 구성하는 정보 모음이다. 관계는 이러한 테이블 간의 상호작용을 기반으로 설정되는 여러 테이블 간의 논리적 연결이다.
>
> > 관계형 데이터베이스(RDB)는 테이블, 행, 열의 정보를 구조화하는 방식이다. RDB에는 테이블을 조인하여 정보 간 관계 또는 링크를 설정할 수 있는 기능이 있어, 여러 데이터 포인트 간에 관계를 쉽게 이해하고 정보를 얻을 수 있다.
>
> ### 관계형 데이터베이스 모델
>
> 1970년대 IBM의 EF Codd가 개발한 관계형 데이터베이스 모델을 사용하면 모든 테이블의 공통 속성을 사용해 다른 테이블과 연관시킬 수 있다. Codd는 계층 구조를 사용하여 데이터를 정리하는 대신 데이터가 포함된 테이블을 재구성하지 않고 테이블에 데이터가 저장, 액세스 및 연결되는 데이터 모델을 사용하는 것으로 전환할 것을 제안했다.
>
> 관계형 데이터베이스는 비즈니스에서 데이터를 구성, 관리, 연결하는데 도움이 되는 스프레드시트 파일 모음이라고 생각하면 쉽다. 관계형 데이터베이스 모델에서 각 '스프레드시트'는 열(속성)과 행(레코드 혹은 튜플)으로 대표되는 정보를 저장하는 테이블이다.
>
> 속성(열)은 데이터 유형을 지정하며 각 레코드(또는 행)는 데이터 유형의 값을 포함한다. 관계형 데이터베이스의 모든 테이블에는 행에서 고유하게 식별 가능한 **기본 키**라는 속성이 있으며, **외래 키**(다른 기존 테이블의 기본 키를 참조)를 사용하여 각 행에서 서로 다른 테이블 간의 관계를 만드는 데 사용할 수 있다.
>
> ### 관계형 데이터베이스의 예
>
> 관계형 데이터베이스 관리 시스템(RDBMS)은 관계형 데이터베이스를 만들고 업데이트하고 관리하는 데 사용하는 프로그램이다. 잘 알려진 RDBMS의 예로는 MySQL, PostgreSQL, MariaDB, MicrosoftSQL Server, Oracle Database 등이 있다. Cloud SQL, Cloud Spanner, AlloyDB 와 같은 클라우드 기반 관계형 데이터베이스는 데이터베이스 유지보수, 패치, 용량 관리, 프로비저닝, 인프라 지원을 위한 관리형 서비스를 제공하여 더욱 많은 인기를 얻고 있다.
>
> ### 관계형 데이터베이스의 이점
>
> 직관적인 데이터 표현 방법을 제공하고 관련 데이터 포인트에 쉽게 액세스 할 수 있다는 장점을 가진다. 따라서 관계형 데이터베이스는 인벤토리 추척부터 트랜잭션 데이터 치리 및 애플리케이션 로깅에 이르기까지 대량의 데이터를 관리해야 하는 조직에서 가장 많이 사용한다.
>
> 1. **유연성**: 전체 데이터베이스 구조를 변경하거나 기존 애플리케이션에 영향을 주지 않고 필요할 떄마다 간편하게 테이블, 관계를 추가 또는 삭제하고 데이터를 변경할 수 있다.
> 2. **ACID 규정 준수**: 관계형 데이터베이스는 ACID(원자성, 일관성, 격리, 내구성) 성능을 지원하므로 오류, 실패, 기타 잠재적 오작동에 관계없이 데이터 유효성을 검사할 수 있다.
> 3. **사용 편의성**: 기술자가 아닌 사용자도 데이터베이스와 상호작용하는 방법을 배울 수 있는 SQL을 사용하여 복잡한 쿼리를 쉽게 실행할 수 있다.
> 4. **공동 작업**: 여러 사용자가 동시에 데이터를 운영하고 액세스할 수 있다. 기본 제공되는 잠금 기능으로 업데이트 도중 데이터에 동시 액세스할 수 없다.
> 5. **내장된 보안 기능**: 역할 기반 보안을 통해 데이터 액세스가 특정 사용자로 제한된다.
> 6. **데이터베이스 정규화**: 관계형 데이터베이스는 데이터 중복성을 줄이고 데이터 무결성을 개선하는 정규화라는 설계 기법을 사용한다.
>
> #### ACID 속성
>
> - **원자성**: 완전한 데이터베이스 트랜잭션을 구성하는 모든 요소를 정의
> - **일관성**: 트랜잭션 후 데이터 포인트를 올바른 상태로 유지하기 위한 규칙을 정의
> - **고립성**: 혼란을 피하기 위해 트랜잭션이 커밋될 때까지 트랜잭션의 효과가 다른 사람에게 보이지 않음
> - **내구성**: 트랜잭션이 커밋되면 데이터 변경 사항이 영구적이 되도록 함
>
> ### 관계형 및 비관계형 데이터베이스
>
> 관계형 및 비관계형 데이터베이스(NoSQL 데이터베이스)의 주요 차이점은 데이터를 저장하고 구성하는 방법이다. 비관계형 데이터베이스는 규칙 기반의 테이블 형식 방식으로 데이터를 저장하지 않는다. 데이터를 연결되지 않은 개별 파일로 저장하며, 문서 또는 리치 미디어 파일과 같은 복잡하고 구조화되지 않은 데이터 유형에 사용할 수 있다.
>
> NoSQL 데이터베이스는 유연한 데이터 모델을 따르므로 자주 변경되는 데이터를 저장하거나 다양한 유형의 데이터를 처리하는 애플리케이션에 적합하다.

* MySQL

> ### MySQL
>
> 가장 널리 사용되고 있는 관계형 데이터베이스 관리 시스템(RDBMS)이다. 오픈 소스이며, 다중 사용자와 다중 스레드를 지원하고, C, C++, JAVA, PHP 등 여러 프로그래밍 언어를 위한 다양한 API를 제공하고 있다. 유닉스, 리눅스, 윈도우 등 다양한 운영체제에서 사용할 수 있으며, 특히 PHP와 함께 웹 개발에 자주 사용된다. 오픈 소스 라이센스를 따르기는 하지만, 상업적으로 사용할 때에는 상업용 라이센스를 구입해야 한다.
>
> ### 장점
>
> 1. 오픈소스 라이센스를 따르기 때문에 무료로 이용이 가능
> 2. 다양한 운영체제와 프로그래밍 언어를 지원
> 3. 크기가 큰 데이터 집합도 빠르고 효율적으로 처리
> 4. 널리 알려진 표준 SQL 형식을 사용
> 5. MySQL 응용 프로그램을 사용자의 용도에 맞게 수정 가능
>
> ### 역사
>
> 1995년 5월 MySQL AB사에 의해 첫번째 버전이 발표되고, 1998년에는 윈도우 버전 MySQL 이 발표된다. 2008년에 썬 마이크로시스템즈 사가 MySQL AB사를 인수하면서 5.1 버전이 발표되고, 2009년에는 오라클과 인수합병되어 권리가 오라클로 넘어간다.

* ORM

> ### 영속성(Persistence)
>
> 데이터를 생성한 프로그램이 종료되더라도 사라지지 않는 데이터의 특성을 말한다. 영속성을 갖지 않는 데이터는 단지 메모리에서만 존재하기 때문에 프로그램을 종료하면 모두 잃어버리게 된다.
>
> - **Object Persistence(영구적인 객체)**
>   - 메모리 상의 데이터를 파일 시스템, 관계형 데이터베이스 혹은 객체 데이터베이스 등을 활용하여 영구적으로 저장하여 영속성을 부여한다.
>   - 데이터를 데이터베이스에 저장하는 방법에는 JDBC(Java에서 사용), Spring JDBC, Persistence Framework(Hibernate, Mybatis 등)
> - **Persistence Layer**
>   - 프로그램의 아키텍처에서, 데이터에 영속성을 부여해주는 계층을 말한다.
>   - JDBC를 이용하여 직접 구현할 수 있지만 Persistence framerwork를 이용한 개발이 많이 이루어진다.
> - **Persistence Framework**
>   - JDBC 프로그래밍의 복잡함이나 번거로움 없이 간단한 작업만으로 데이터베이스에 연동되는 시스템을 빠르게 개발할 수 있으며 안정적인 구동을 보장한다.
>   - SQL Mapper와 ORM으로 나눌 수 있다.
> 
> ### ORM(Object Relational Mapping), 객체-관계 매핑
>
> 객체와 관계형 데이터베이스의 데이터를 자동으로 매핑(연결)해주는 것을 말한다. 이 과정에서 객체 지향 프로그래밍은 **클래스**를 상요하고, 관계형 데이터베이스는 **테이블**을 사용한다. 객체 모델과 관계형 모델 간에 불이리가 존재하며, ORM을 통해 객체 간의 관계를 바탕으로 SQL을 자동으로 생성하여 불일치를 해결한다.
>
> 데이터베이스 데이터와 Object 필드를 매핑하며, 객체를 통해 간접적으로 데이터베이스 데이터를 다룰 수 있다. Persistent API 라고도 불린다.
>
> ### 장점
>
> 객체 지향적인 코드로 인해 더 직관적이고 비즈니스 로직에 더 집중할 수 있게 도와준다. ORM을 이용하면 SQL Query 가 아닌 직관적이 코드(메서드)로 데이터를 조작할 수 있어 개발자가 객체 모델로 프로그래밍하는 데 집중할 수 있게 도와준다. 선언문, 할당, 종료 같은 부수적인 코드가 매우 줄고, 각종 객체에 대한 코드를 별도로 작성하여 코드의 가독성을 올려준다. SQL의 절차적이고 순차적인 접근이 아닌 객체 지향적인 접근으로 인해 생산성이 증가한다.
>
> 재사용 및 유지보수의 편리성이 증가한다. ORM은 독립적으로 작성되어 있고, 해당 객체들을 재활용할 수 있다. 때문에 모델에서 가공된 데이터를 컨트롤러에 의해 뷰와 합쳐지는 형태로 패턴을 견고하게 다지는데 유리하다. 매핑정보가 명확하여 ERD를 보는 것에 대한 의존도를 낮출 수 있다.
>
> DBMS에 대한 종속성이 줄어든다. 객체 간의 관계를 바탕으로 SQL을 자동으로 생성하기 때문에 RDBMS의 데이터 구조와 Java의 객체 지향 모델 사이의 간격을 좁힐 수 있다. 대부분 ORM 솔루션은 DB에 종속적이지 않으며, 이 말은 구현 방법 뿐만 아니라 많은 솔루션에 자료형 타입까지 종속적이지 않다는 뜻이다. 프로그래머는 Object에 집중함으로 극단적으로 DBMS를 교체하는 거대한 작업에도 비교적 적은 리스크와 시간이 소요된다.
>
> ### 단점
>
> 완벽한 ORM으로만 서비스를 구현하기가 어렵다. ORM은 사용하기는 편하지만 서례에는 신중해야 하며, 프로젝트의 복잡성이 커질 경우 난이도가 올라갈 수 있다. 잘못 구현된 경우에는 속도 저하 및 일관성이 무너지는 문제점이 발생할 수 있다. 자주 사용되는 대형 쿼리는 속도를 위해 SP 를 쓰는 등 별도 튜닝이 필요한 경우가 있다.
>
> 프로시저가 많은 시스템에서는 ORM의 객체 지향적인 장점을 활용하기 어렵다. 이미 프로시저가 많은 시스템에서는 다시 객체로 바꾸어야하며, 그 과정에서 생산성 저하나 리스크가 많이 발생한다.
>
> ### The Object-Relational Impedance Mismatch
> 
> 객체 모델을 관계형 모델에 저장할 때 발생하는 문제, 즉 **패러다임의 불일치**에서 오는 문제를 말한다. 이 문제를 해결하는 것이 ORM의 과제이다.
>
> Persistence란 애플리케이션의 데이터가 애플리케이션 프로세스 범위를 넘어서 지속되는 것을 말한다.
>
> RDBMS는 데이터를 테이블 형식으로 표현하지만, 객체지향 모델은 객체 그래프로 데이터를 표현하기 때문에 객체를 테이블 형식으로 저장하면 다섯 가지 불일치 문제가 발생한다.
> 
> - Granularity(세분성)
>   - 경우에 따라 데이터베이스에 있는 테이블 수보다 더 많은 클래스를 가진 객체 모델이 있을 수 있다. 객페 모델이 관계형 모델보다 더 세분화되어 있기 때문이다.
> - Subtypes(상속)
>   - RDBMS에는 상속이란 개념이 없다.
> - Identity(동일성)
>   - RDBMS는 정확히 하나의 동일성을 보장하는 개념인 기본 키(Primary Key, PK)를 제공한다. 하지만 객체는 동일성(==) 뿐만 아니라 동등성(equals())을 모두 정의한다.
> - Associations(연관성)
>   - 객체지향 언어에서 연관관계는 단방향 참조로만 이루어진다. RDBMS는 왜래 키(Foreign Key, FK) 하나를 사용해서 양방향 참조를 가진다. 하지만 객체 모델은 단방향 참조가 기본이고 양방향을 참조하려면 양쪽에 연관을 두번 정의해야 한다.
> - Data navigation(데이터 탐색)
>   - 객체 지향 언어에서는 데이터에 접근할 때 하나의 객체에서 출발해 다른 연결로 이어지는 객체 그래프 탐색 방식을 사용한다. 하지만 이 방법은 관계형 데이터베이스에서 비효율적이므로 RDBMS는 SQL 쿼리를 최소화하기 위해 JOIN을 통해 여러 엔티티를 불러와서 데이터를 탐색한다.

* Hash
  * scrypt

> ### 안전한 패스워드 저장
>
> "보안 시스템은 가장 약한 연결 고리만큼만 강하다."
>
> 보안 시스템은 여러 부분으로 이루어 지는데, 공격자는 이 중 가장 취약한 부분을 공격할 것을 가정해야 하므로 보안시스템에서 다른 고리가 얼마나 강한지는 문제가 되지 않는다. 즉, 약한 부분이 얼마나 약한가에 의해 보안 시스템의 안정성이 결정된다.
>
> ### 단방향 해시 함수
>
> 단순 텍스트로 패스워드를 저장하는 일은 보통 일어나지 않으므로, 보통 프로그래머는 단방향 해시 함수(one-way hash function)의 다이제스트(digest) 방식으로 패스워드를 저장하게 된다.
>
> 단방향 해시 함수는 수학적인 연산을 통해 원본 메시지를 변환하여 암호화된 메시지인 다이제스트를 생성한다. 원본 메시지를 알면 암호화된 메시지를 구하기는 쉽지만 암호화된 메시지로는 원본 메시지를 구할 수 없어야하며 이를 '단방향성'이라고 한다.
>
> 대부분의 해시 함수는 입력 값의 일부가 변경되었을 때 다이제스트가 완전히 달라지도록 설계되어 있다. 이 특징을 avalanche 효과라고 하며, 원본 패스워드를 추론하기 어렵게 만드는 중요한 요소이다.
>
> ### 단방향 해시 함수의 문제점
>
> 대부분 웹 사이트에서는 SHA-256과 같은 해시 함수를 사용해 패스워드를 암호화해 저장하고 값을 비교하는 것만으로 충분한 암호화 매커니즘을 적용했다고 생각하지만, 실제로는 두 가지 문제점이 있다.
>
> #### 인식 가능성(recognizability)
>
> 동일한 메시지가 언제나 동일한 다이제스트를 갖는다면, 공격자가 전처리된 다이제스트를 가능한 많이 확보한 다음 이를 탈취한 다이제스트와 비교하여 원본 메시지를 찾거나 동일한 효과의 메시지를 찾을 수 있다. 이와 같은 다이제스트 목록을 레인보우 테이블(rainbow table)이라고 하고, 이와 같은 공격 방식을 레인보우 공격(rainbow attack)이라고 한다. 게다가 다른 사용자의 패스워드가 같으면 다이제스트도 같으므로 한꺼번에 탈취될 수 있다.
>
> #### 속도(speed)
>
> 해시 함수는 암호학에서 널리 사용되지만 원래 패스워드를 저장하기 위해 설계된 것이 아니라 짧은 시간에 데이터를 검색하기 위해 설계된 것이다. 해시 함수의 빠른 처리 속도로 인해 공격자는 매우 빠른 속도로 임의의 문자열의 다이제스트와 해킹 대상의 다이제스트를 비교할 수 있다. (MD5를 사용한 경우 일반적인 장비를 이용하여 초당 56억개의 다이제스트를 대입할 수 있다.)
>
> 이러한 방식으로 패스워드를 추측하면 패스워드가 충분히 길거나 복잡하지 않은 경우에는 그리 긴 시간이 걸리지 않는다. 대부분의 사용자는 패스워드가 길거나 복잡하지 않고, 동일한 패스워드를 사용하는 경우도 많기 때문이다.
>
> 반면 사용자는 웹 사이트에서 패스워드를 인증하는 데 걸리는 시간에 민감하지 않으므로, 해시 함수의 빠른 처리 속도는 사용자들보다 공격자들에게 더 큰 편의성을 제공하게 된다.
>
> ### 단방향 해시 함수 보완하기
>
> #### 솔팅(salting)
>
> 솔트는 단방향 해시 함수에서 다이제스트를 생성할 때 추가되는 바이트 단위의 임의의 문자열이다. 그리고 이 원본 메시지에 문자열을 추가하여 다이제스트를 생성하는 것을 솔팅(salting)이라고 한다. 이 방법을 사용하면 공격자가 솔팅된 다이제스트를 대상으로 패스워드 일치 여부를 알기 어렵고, 사용자별로 다른 솔트를 사용한다면 인식 가능성 문제가 크게 개선된다.
>
> 모든 패스워드가 고유의 솔트를 갖고 솔트의 길이는 32바이트 이상이어야 솔트와 다이제스트를 추측하기 어렵다.
>
> #### 키 스트레칭(key stretching)
>
> 입력한 패스워드의 다이제스트를 생성하고, 생성된 다이제스트를 입력값으로 하여 다이제스트를 생성하고, 이를 반복하는 방법으로 다이제스트를 생성할 수도 있다. 이렇게 하면 패스워드드를 동일한 횟수만큼 해시해야만 일치 여부를 확인할 수 있다.
>
> 잘 설계된 패스워드 저장 시스템에서는 하나의 다이제스트를 생성할 때 어느정도(일반적으로는 0.2초 이상) 시간이 소요되도록 한다. 이는 억지 기법 공격(brute-force attack)으로 패스워드를 추측하는 데 많은 시간이 소요되게 하기 위한 것이다. 일반적인 장비로 1초에 50억개 이상의 다이제스트를 비교할 수 있지만, 키 스트레칭을 적용하면 초당 5번정도만 비교할 수 있게 된다.
>
> ### Adaptive Key Derivation Functions
>
> adaptive key derivation function은 다이제스트를 생성할 때 솔팅과 키 스트레칭을 반복하여 솔트와 패스워드 외에도 입력 값을 추가하여 공격자가 쉽게 다이제스트를 유추할 수 없도록 하고, 보안의 강도를 선택할 수 있다.
>
> #### PBKDF2
>
> 가장 많이 사용되는 key derivation function은 PBKDF2(Password-Based Key Drivation Function)이다. 해시 함수의 컨테이너인 PBKDF2는 솔트를 적용한 후 해시 함수의 반복 횟수를 임의로 선택할 수 있다.
>
> `DIGEST = PBKDF2(PRF, Password, Salt, c, DLen)`
>
> - PRF: 난수(HMAC 등)
> - Password: 패스워드
> - Salt: 암호학 솔트
> - c: 원하는 iteration 반복 수
> - DLen: 원하는 다이제스트 길이
>
> PBKDF2는 NIST(National Institute of Standards and Technology, 미국표준기술연구소)에서 승인된 알고리즘이고, 미국 정부 시스템에서도 사용된다.
>
> #### bcrypt
>
> bcrypt는 애초부터 패스워드 저장을 목적으로 설계되었다. 1999년 발표되었고, 현재까지 사용되는 가장 강력한 해시 매커니즘 중 하나이며, 보안에 집착하기로 유명한 OpenBSD에서 기본 암호 인증 매커니즘으로 사용되고 있다.
>
> bcrypt에서 "work factor" 인자는 하나의 해시 다이제스트를 생성하는 데 얼마만큼의 처리 과정을 수행할 지 결정한다. "work factor" 를 조정하는 것만으로 간단하게 시스템의 보안성을 높일 수 있다. 다만, PBKDF2나 scrypt와는 달리 입력 값으로 72 bytes character를 사용해야 하는 제약이 있다.
>
> #### scrypt
>
> scrypt는 PBKDF2와 유사한 adaptive key derivation function이며 2012년 발표되었다. scrypt는 다이제스트를 생성할 때 메모리 오버헤드를 갖도록 설계되어, 억지 기법 공격을 시도할 때 병렬화 처리가 매우 어렵다.
>
> `DIGEST = scrypt(Password, Salt, N, r, p, DLen)`
>
> - Password: 패스워드
> - Salt: 암호학 솔트
> - N: CPU 비용
> - r: 메모리 비용
> - p: 병렬화(parallelization)
> - DLen: 원하는 다이제스트 길이
>
> ### 정리
>
> MD5, SHA-1, SHA-256, SHA-512 등의 해시 함수는 메시지 인증과 무결성 체크를 위한 것이다. 이를 패스워드 인증을 위해 사용하면 앞서 말한 인식 가능성과 빠른 처리 속도에 기인하는 취약점이 존재한다. 이를 해결하기 위해서는 key dervation function을 사용하는 것을 권장한다.
>
> 보안 규정을 준수하고, 서드파티의 라이브러리에 의존하지 않으면서 다이제스트를 생성하려면 PBKDF2-HMAC-SHA-256/SHA-512를 사용하면 된다.
>
> 매우 강력한 패스워드 다이제스트를 생성하는 시스템을 쉽게 구현하고 싶다면 bcrypt를 사용하는 것이 좋다. 대부분 프로그래밍 언어에서 라이브러리를 사용할 수 있고, 예제도 쉽게 구할 수 있다.
>
> 구현하려는 시스템이 민감한 정보를 다루고, 보안 시스템을 구현하는 데 많은 비용을 투자할 수 있다면 scrypt를 이용하면 된다.

## Checklist
* RDBMS 테이블의 정규화는 무엇인가요?
* MySQL 외의 RDB에는 어떤 것들이 있나요?
  * Relational Database 외에 다른 DB에는 어떤 것들이 있을까요?
* RDBMS에서 테이블의 인덱싱은 무엇인가요? 인덱싱을 하면 어떤 점이 다르며, 어떤 식으로 동작하나요?

> ### 인덱스
>
> 인덱스는 우리 말로 색인과 같은 개념이다.
>
> ### 장점
>
> 인덱스를 사용하는 이유는 검색 속도를 높이기 위함이다. 인덱스가 없다면 테이블 전체를 key 순서대로 순차 탐색해야 한다.
>
> ### 단점
>
> 인덱스를 담아놓기 위한 추가 테이블이 필요하여 공간을 더 사용하게 된다. 인덱스와 생성, 수정에 대한 오버헤드가 존재하며, 삽입/수정/삭제 성능이 하락할 수 있다.
>
> 인덱스는 B tree 자료 구조로 구현하는데, 인덱스가 들어간 key가 바뀌면 B 트리의 균형이 깨지면서 B 트리 구조를 수정해야 할 경우가 생겨, 추가적인 I/O 성능이 하락할 수 있다.
>
> 데이터를 삽입/삭제하면 B 트리의 균형이 깨져 트리의 구조를 수정해야 한다. B 트리에서의 수정은 삭제+삽입으로 구현되는데, 이는 인덱스의 순서를 유지해야하기 때문이다.
>
> 따라서 SELECT 쿼리를 많이 사용하며, INSERT/UPDATE/DELETE를 적게 사용한다면 인덱스 사용을 고려해볼 수 있다.
>
> ### 종류
>
> #### 클러스터드 인덱스
>
> 테이블 당 한개만 생성 가능하며, 행 데이터를 인덱스로 지정한 컬럼에 맞춰 정렬시킨다. 데이터 INSERT/DELETE 마다 행 정렬이 일어나므로, 이들 쿼리를 자주 사용할 경우 성능이 저하될 수 있다. '정렬'이 일어난다는 것에 유의한다.
>
> #### 넌-클러스터드 인덱스
>
> 테이블 당 여러 컬럼에 대해 생성이 가능하며, 별도의 공간에 인덱스 테이블을 생성하여, 정렬 효과를 구현한다.
>
> #### 차이점
>
> 두 인덱스의 차이점은, 데이터 순서를 어떻게 구현할 것인가에서 나타난다.
>
> 클러스터드 인덱스는 데이터를 직접 정렬해서 순서를 구현하고, 넌-클러스터드 인덱스는 별도의 인덱스 테이블을 순서대로 만들어 정렬하 효과를 만든다.
>
> 비슷한 데이터를 여러개 가져온다고 하면 비슷한 데이터를 모두 인접한 곳에 위치시키는 클러스터드 인덱스가 유리하다.(DB가 HDD로 구성되었을 경우 등)

* ORM을 사용하는 것은 사용하지 않는 것에 비해 어떤 장단점을 가지고 있나요?
  * 자바스크립트 생태계의 ORM에는 어떤 것들이 있나요?
* 모델간의 1:1, 1:N, N:M 관계는 각각 무엇이고 어떨 때 사용하나요?
* DB에 사용자의 암호를 평문으로 저장하지 않고도 사용자의 암호를 인증하는 것이 가능한 이유는 무엇일까요?
  * 해시 함수에는 어떤 것이 있나요?
  * 사용자의 암호를 해싱하여 저장할 때 어떤 식으로 저장하는 것이 보안에 좋을까요?

## Quest
* 이번에는 메모장을 파일이 아닌 DB기반으로 만들어 보고자 합니다.
  * 적절한 테이블을 설계해 보세요.
  * Sequelize를 이용하여 데이터의 모델을 만들고 어플리케이션에 적용해 보세요.
  * 사용자의 비밀번호는 해싱을 통해 저장되어야 합니다.

## Advanced
* Object–relational impedance mismatch란 어떤 개념인가요?
* Foreign Key란 무엇인가요? 이것을 사용할 때의 장점과 단점은 무엇일까요?
* 이전에 쓰이던 해시함수들에는 어떤 것이 있을까요? 패스워드 해싱의 추세의 역사는 어떻게 이어져왔나요?
