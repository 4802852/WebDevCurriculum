# Quest09

## Topics
* Cookie

> ### HTTP 쿠키
>
> HTTP 쿠키는 서버가 사용자의 웹 브라우저에 전송하는 작은 데이터 조각이다. 브라우저는 그 데이터 조각들을 저장해 놓았다가, 동일한 서버에 재요청 시 저장된 데이터를 함께 전송한다. 쿠키는 두 요청이 동일한 브라우저에서 들어왔는지 아닌지를 판단할 때 주로 사용한다.
>
> 쿠키는 주로 세 가지 목적을 위해 사용된다.
>
> 1. 세션 관리(Session Management): 서버에 저장해야 할 로그인, 장바구니, 게임 스코어 등의 정보 관리
> 2. 개인화(Personalization): 사용자 선호, 테마 등의 세팅
> 3. 트래킹(Tracking): 사용자 행동을 기록하고 분석하는 용도
>
> 과거에는 쿠키를 사용하는 것이 데이터를 클라이언트에 저장할 수 있는 유일한 방법이었지만, 지금은 modern storage APIs 를 이용하여 정보를 저장하는 것이 권장된다. 모든 요청마다 쿠키가 함께 전송되기 때문에 성능이 떨어지는 원인이 될 수 있다.
>
> ### 쿠키 만들기
>
> HTTP 요청을 수신할 때, 서버는 응답과 함께 `Set-Cookie` 헤더를 전송할 수 있다. 쿠키는 보통 브라우저에 의해 저장되며, 그 후 쿠키는 같은 서버에 의해 만들어진 요청들의 Cookie HTTP 헤어 단에 포함되어 전송된다.
>
> #### 쿠키의 라이프타임
>
> 세션 쿠키는 현재 세션이 끝날 때 삭제된다. 브라우저는 '현재 세션'이 끝나는 시점을 정의하며, 어떤 브라우저들은 재시작할 때 세션을 복원해 세션 쿠키가 무기한 존재할 수 있도록 한다.
>
> 영속적인 쿠키는 `Expires` 속성에 명시된 날짜에 삭제되거나, `Max-Age` 속성에 명시된 기간 이후헤 삭제된다.
>
> ### Secure 과 HttpOnly 쿠키
>
> Secure 쿠키는 HTTPS 프로토콜 상에서 암호화된 요청일 경우에만 전송된다. 하지만 본질적으로 안전하지 않고 실질적인 보안을 제공하지 않기 때문에 민감한 정보는 쿠키에 저장하면 안된다.
>
> Cross-site 스크립팅(XSS) 공격을 방지하기 위해, HttpOnly 쿠키는 JavaScript 의 `Document.cookie` API 에 접근할 수 없고, 서버에 전송되기만 한다.
>
> #### 쿠키의 스코프
>
> `Domain`, `Path` 디렉티브는 쿠키의 스코프(어떤 URL 을 쿠키카 보내야 하는지)를 정의한다.
>
> `Domain` 은 쿠키카 전송되게 될 호스트들을 명시한다. 만약 명시되지 않으면, 현재 문서 위치의 호스트 일부를 기본값으로 한다. 도메인이 명시되면, 서브 도메인들은 포함된다.
>
> `Path` 는 Cookie 헤더를 전송하기 위해 요청되는 URL 내에 반드시 존재해야 하는 URL 경로이다.
>
> ### 보안
>
> #### 세션 하이재킹과 XSS
>
> 쿠키는 대개 웹 애플리케이션에서 사용자와 그들의 인증된 세션을 식별하기 위해 사용된다. 그래서 쿠키를 가로채는 것은 인증된 사용자의 세션 하이재킹으로 이어질 수 있다. 쿠키를 가로채는 일반적인 방법은 소셜 공학 사용 혹은 애플리케이션 내 XSS 취약점을 이용하는 것을 포함한다.
>
> HttpOnly 속성은 자바스크립트를 통해 쿠키 값에 접근하는 것을 막아 이런 공격을 누그러뜨리는데 도움을 줄 수 있다.
>
> #### Cross-site 요청 위조 (CSRF)
>
> 필터링되지 않은 채팅이나 포럼 페이지 내에 은행 서버에 입금하는 실제 요청 대신에 다른 요청을 하는 이미지가 있을 경우, 은행 계좌에 로그인 되어있고 쿠키가 여전히 유효하다면(그리고 별다른 검증 절차가 존재하지 않는다면), 해당 이미지를 포함하는 HTML 을 로드하자마자 돈이 송금되게 된다.
>
> 이를 방지하기 위한 기술이 몇가지 있다.
>
> 1. 입력 필터링
> 2. 모든 민감한 동작에 필수로 요구되는 확인 절차가 수행되도록 한다.
> 3. 민감한 동작에 사용되는 쿠키는 짧은 수명을 갖도록 설정
> 
> SWASP CSRF 예방 치트 시트를 참고하면 더 많은 예방팁을 알 수 있다.
>
> ### 트래킹과 프라이버시
>
> #### 서드파티 쿠키
>
> 쿠키는 그에 관련된 도메인을 가지는데, 이 도메인이 현재 보고 있는 페이지의 도메인과 동일하다면 그 쿠키는 퍼스트파티 쿠키이다. 도메인이 다르면 서드파티 쿠키라고 부르게 된다. 퍼스트파티 쿠키가 그것을 설정한 서버에만 전송되는 반면, 윂 페이지는 다른 도메인 서버상에 저장된 (광고 배너와 같은) 이미지 혹은 컴포넌트를 포함할 수 있다. 이런 서드파티 컴포넌트를 통해 전송되는 쿠키들을 서드파티 쿠키라고 부르며 웹을 통한 광고와 트래킹에 주로 사용된다.
>
> 서드파티 쿠키를 사용하면서 이를 공개하고 있지 않다면, 쿠키 사용이 밝혀질 경우 소비자 신뢰를 잃을 수 있다.
>
> #### Do-Not-Track
>
> 쿠키 사용에 대한 합법적이거나 기술적인 요구사항은 없지만 `DNT` 헤더는 웹 애플리케이션이 트래킹 혹은 개인 사용자의 cross-site 사용자 트래킹 모두를 비활성화하는 신호로 사용될 수 있다.

* Session

> ### HTTP
>
> HTTP 는 클라이언트-서버 사이에 이루어지는 요청/응답 프로토콜이다. HTTP 는 다음 두가지 특징을 가진다.
>
> 1. Connectionless (비연결성): 연결을 맺은 서버-클라이언트 관계에서 클라이언트의 요청에 대해 서버가 응답을 마치면 그 연결을 끊는 성질.
> 2. Stateless (무상태성): 클라이언트의 상태를 저장하지 않는 성질.
>
> HTTP 는 인터넷 상 불특정 다수의 통신 환경을 기초로 설계되었다. 따라서 한 번 맺은 연결을 지속적으로 유지한다면 자원을 많이 소요하게 되므로 매번 연겨을 맺는 편이 효율적이다.
>
> 하지만 로그인 정보를 저장하거나, 장바구니 상태를 저장하는 등 클라이언트를 구분하고 그 상태를 저장할 필요가 생기게 되었다. 이 수단이 쿠키와 세션이다.
>
> ### 쿠키
>
> 쿠키는 다음과 같은 방식으로 HTTP 의 stateless 한 성질을 보완하였다.
>
> 1. 클라이언트가 서버에게 페이지 정보를 요청
> 2. 서버는 클라이언트에 대한 쿠키 생성 후, HTTP 응답 헤더에 쿠키를 포함하여 응답
> 3. 클라이언트의 요청과 서버의 응답이 끝나면 HTTP 의 비연결성으로 연결 끊김
> 4. 새로운 요청을 할때, 클라이언트는 이전에 받은 쿠키값을 보관하고 있다가 HTTP 요청 헤더에 값을 포함하여 요청
> 5. 서버는 쿠키값을 보고 이전에 보낸 클라이언트를 인식
> 
> 쿠키는 사용자 입장에서, 별도의 인증 과정을 거치지 않고 서버가 나를 쉽게 기억할 수 있다는 장점을 갖고 있다. ID-PW 자동완성 기능, 지난번 읽었던 글이 새로운 글에 업데이트 되지 않도록 하는 등 가벼운 일에 쿠키가 사용된다.
>
> 쿠키값은 쉽게 수정이 가능하며, 텍스트로 저장되다보니 더욱 악의적인 공격자에 의해 변조될 가능성이 크다는 단점이 있다.
>
> ### 세션
>
> 세션은 쿠키와 달리 서버에 인증하기 위한 클라이언트 정보를 서버 단에서 저장 및 관리하는 방식이다. 서버는 서버가 클라이언트에 부여한 세션 ID 를 통해 클라이언트 정보를 기억하게 된다. 하지만 이 세션 ID 는 쿠키를 통해 관리된다.
>
> 1. 클라이언트가 서버에게 페이지 정보를 요청
> 2. 서버는 클라이언트에 대한 쿠키 생성 후, HTTP 응답 헤더에 세션 ID 값이 담긴 쿠키를 포함하여 응답
> 3. 요청/응답이 끝나면 연결 끊김
> 4. 새로운 요청을 할 경우, 이전에 받은 쿠키값을 보관하고 있다가 HTTP 요청 헤더에 세션 ID 값이 담긴 쿠키를 포함하여 요청
> 5. 서버는 쿠키 내 세션 ID 값을 보고 이전에 요청을 보낸 클라이언트를 인식하여 상태를 기억
>
> 세션은 세션 ID 는 클라이언트에 있다고 하더라도 클라이언트의 정보 자체는 서버에 저장되어있기 때문에 쿠키에 비해 그나마 안전하다는 장점이 있다.
>
> 하지만 쿠키에 비해 조금 느리고, 세션은 서버의 자원을 사용한다는 단점을 가지며, 세션 하이재킹 등의 해킹 위험성이 남아있다.

* JWT
 
> ### JWT
> 
> JWT는 JSON Web Token의 약자로, 전자 서명 된 URL-safe(URL로 이용할 수 있는 문자로만 구성된) JSON 이다. 전자 서명은 JSON의 변조를 체크할 수 있게 되어있다. JWT 는 속성 정보 (Claim)를 JSON 데이터 구조로 표현한 토큰으로 RFC7519 표준이다. JWT 는 서버와 클라이언트 간 정보를 주고 받을 때 HTTP request 헤더에 JSON 토큰을 넣은 후 서버는 별도의 인증 과정 없이 헤더에 포함되어이 있는 JWT 정보를 통해 인증한다. JWT 는 HMAC 알고리즘을 사용하여 비밀키 또는 RSA 를 이용한 Public Key/Private Key 쌍으로 서명할 수 있다.
>
> ### JWT 토큰 구성
>
> JWT 는 세 파트로 나누어지며, 각 파트는 점으로 구분하여 aaaaaa.bbbbbb.cccccc 와 같은 방식으로 표현된다. 순서대로 헤더(Header), 페이로드(Payload), 서명(Signature)를 나타낸다.
>
> Header 는 토큰의 타입과 해시 암호화 알고리즘으로 구성되어 있다. 토큰의 유형과 HMAC, SHA256 또는 RSA 와 같이 해시 알고리즘을 나타내게 되어있다.
>
> Payload 는 토큰에 담을 클레임(Claim) 정보를 포함한다. Payload 에 담는 정보의 한 조각을 Claim 이라고 부르고, 이는 name/value 의 한 쌍으로 구성되어 있다. 토큰에는 여러개의 클레임을 넣을 수 있다. 클레임의 정보는 등록된 (registered) 클레임, 공개 (public) 클레임, 비공개 (private) 클레임으로 세 종류가 있다.
>
> Signature 는 secret key 를 포함하여 암호화되어 있다.
>
> ### JWT 의 프로세스
>
> 1. 사용자가 아이디와 패스워드를 입력하여 로그인
> 2. 서버는 요청을 확인하고 secret key 를 통해 Access token 을 발급, 클라이언트에 전달
> 3. 클라이언트에서 서버에 요청 시 Authorization header 에 Access token 담아서 요청
> 4. 서버는 JWT Signature 를 체크하고 Payload 로 부터 사용자 정보를 확인해 데이터 반환
>
> ### JWT 의 장점
>
> 사용자 인증에 필요한 정보가 토큰 자체에 포함되기 때문에 별도의 인증 저장소가 필요하지 않다는 점이 장점이다. 중앙 집중식 인증 서버와 데이터베이스에 의존하지 않는 쉬운 인증 및 인가 방법을 제공한다. 개별 서비스에는 검증에 필요한 비밀 키를 처리하기 위한 미들웨어가 필요하며, 검증 과정에서는 매개 변수와 토큰의 만료를 검사한다.
>
> - URL 파라미터와 헤더로 사용
> - 수평 스케일 용이
> - 디버깅 및 관리 용이
> - 트래픽 부담 적음
> - REST 서비스로 제공 가능
> - 내장된 만료
> - 독립적인 성질
>
> ### JWT 의 단점
>
> 토큰은 클라이언트에 저장되어 데이터베이스에서 사용자 정보를 조작하더라도 토큰에 직접 적용할 수 없고, 필드가 추가되면 토큰이 커지게 된다. 토큰이 거의 모든 요청에 대해 전송되기 때문에 데이터 트래픽 크기에 영향을 미칠 수 있다.

## Checklist
* 쿠키란 무엇일까요?
  * 쿠키는 어떤 식으로 동작하나요?
  * 쿠키는 어떤 식으로 서버와 클라이언트 사이에 정보를 주고받나요?
* 웹 어플리케이션의 세션이란 무엇일까요?
  * 세션의 ID와 내용은 각각 어디에 저장되고 어떻게 서버와 교환되나요?
* JWT란 무엇인가요?
  * JWT 토큰은 어디에 저장되고 어떻게 서버와 교환되나요?
* 세션에 비해 JWT가 가지는 장점은 무엇인가요? 또 JWT에 비해 세션이 가지는 장점은 무엇인가요?

## Advanced
* Web Authentication API(WebAuthn)은 무엇인가요?

> ### WebAuthn
>
> 웹 인증(WebAuthn 또는 FIDO2.0)은 비밀번호가 필요 없는 인증 표준이다. 생체인식 키(지문 등)이나 하드웨어(Yubikey 키 등)을 이용하여 아이덴티티를 인증한다.
>
> ### 웹 인증의 역사
>
> 비밀번호는 해킹 관련 침해의 80%가 탈취된 자격 증명에서 비롯될 정도로 취약한 수단이다. 이를 해결하기 위해 이중 요소 인증 방법이 사용되기도 하였다.
>
> 1. 등록: 휴대전화와 같은 디바이스를 사용자 프로필에 연결
> 2. 로그인: 사용자가 이름과 비밀번호를 입력
> 3. 요청: 서버가 디바이스에 로그인 요청을 전송
> 4. 완료: 사용자가 디바이스에 수신된 지침에 따라 사이트에 로그인
>
> 효율적으로 보이지만 실제로 구현하는 곳은 많지 않았고, W3C(World Wide Web Consortium)은 사용자 경험을 개선하는 동시에 보안까지 강화할 수 있는 새로운 방법에 대한 필요성을 느껴 2019년 웹 인증 API 를 출시하였고, 이후 널리 도입되었다.
>
> ### 웹 인증의 원리
>
> 웹 인증은 애플리케이션 프로그래밍 인터페이스, 즉 API 이다. 서버가 비밀번호 없이 사용자를 등록하고 인식할 수 있는 이유도 바로 이 API가 있기 때문이다. 대부분의 사이트는 사용자가 고유한 사용자 이름과 비밀번호로 가입하여 회원이 될 수 있지만, 웹 인증은 이 모든것을 대신할 수 있다.
>
> - 등록: 사용자 이름과 자격 증명 입력. 얼굴, 지문과 같은 생체 인식 데이터 혹은 항상 가지고 다니는 하드웨어를 1개 등록한다.
> - 권한 인증: 자격 증명이 생성/확인되면 일반적으로 사용자 운영 체제에서 **인증자**라는 것에 저장된다.
>
> 사용자가 웹 인증이 활성화되어 있는 웹사이트에 로그인하려면 다음과 같은 과정을 거친다.
>
> - 등록: 사용자 이름을 선택하고, 비밀번호 대신 생체 인식 데이터를 제시하거나 물리적인 보안 키를 등록한다.
> - 반복: 사이트에 로그인할 때마다 비밀번호와 입증할 수 있는 등록 세부정보를 입력한다.
>
> 위의 프로세스를 마치면 **자격 증명**이라고 하는 정보를 얻게된다. 이 자격 증명은 웹사이트에서 사용되는 키페어(공개 키 1개와 비공개 키 1개)이다. 비공개 키는 개인 디바이스에만 저장되며, 어디에도 전송되지 않는다.
>
> 1. 시도: 사용자 이름을 입력하는 등의 방법으로 서버에 대한 액세스 권한을 요청한다. 시스템이 사용자의 키 지정 위치에 대한 지침과 자격 증명을 전송한다.
> 2. 접속: 브라우저가 인증자와 연결하여 사용자에게 모든 권한 비트가 있는지 확인한 후 액세스허용 여부를 결정.
> 3. 승인: 인증자가 로그인 승인에 서명하여 전송.
> 4. 서버 접속: 서버가 전송된 모든 정보를 검토하여 액세스 허용.
>
> ### 웹 인증 구현 방법
>
> W3C 팀의 목표는 도입 확산이었으므로, 많은 웹 사이트들이 이용할 수 있도록 간편성과 용이성을 염두에 두고 코드를 작성하였다.
>
> - Navigator.credentials.create 는 새로운 계정을 등록하거나, 새로운 키를 기존 계정과 페어링하는 데 사용
> - Navigator.credentials.get 은 사용자가 기존 자격 증명으로 로그인할 때 사용
>
> ### 웹 인증의 장점
>
> 기존 로그인 시스템을 변경하면 웹 사이트 운영자와 사용자 모두에게 골칫거리가 된다. 하지만 새로운 기술에서 얻을 수 있는 이점이 많다.
>
> - 보호: 인증 방식이 사이트마다 다르기 때문에 탈취한 비밀번호를 가지고 있어도 액세스 불가능.
> - 컴플라이언스: 비밀번호 재사용이 심각하다는 것은 사실이지만 사용자들에게 비밀번호를 재사용하지 않도록 강요할 수는 없다. 하지만 웹 인증으로 전환하면 액세스 권한을 위해 규칙을 따를 수 밖에 없다.
> - 위험 완화: 해커들은 사용자의 이름과 비밀번호를 탈취하기 위해 데이터베이스에 침입하지만, 웹 인증의 데이터는 재사용이 불가능하기 때문에 해커의 시도가 줄어들 수 있다.
> - 고객 경험 개선: 사용자 이름/비밀번호를 기억하지 못해 떠나는 사용자들이 많다. 웹 인증 환경에서는 그러한 경우가 발생하지 않는다.
